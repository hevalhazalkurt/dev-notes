# Dev-Notes
You can check [my personal blog](https://hevalhazalkurt.com/) for a better reading experience.

<br>


* [Shallow vs Deep Copies in Python, What You Think You Know (but Might Not)](notes/0001_Shallow_vs_Deep_Copies_in_Python_What_You_Think_You_Know_but_Might_Not.md)
* [Trash Talk: Understanding Python’s Garbage Collector](notes/0002_Trash_Talk_Understanding_Pythons_Garbage_Collector.md)
* [The Power of `yield from` in Python Generators](notes/0003_The_Power_of_yield_from_in_Python_Generators.md)
* [How Async/Await Evolved from Generator-Based Coroutines](notes/0004_How_Async_Await_Evolved_from_Generator_Based_Coroutines.md)
* [How Order Changes Behavior in Chained Decorators](notes/0005_How_Order_Changes_Behavior_in_Chained_Decorators.md)
* [Creating Declarative APIs with Class Decorators in Python](notes/0006_Creating_Declarative_APIs_with_Class_Decorators_in_Python.md)
* [Keys to Mastering Python Method Decorators](notes/0007_Keys_to_Mastering_Python_Method_Decorators.md)
* [The Danger of Overusing `is` Instead of `==` in Python](notes/0008_The_Danger_of_Overusing_is_Instead_of_==_in_Python.md)
* [Behind the Underscores EP01: Understanding Python’s Special Methods Conceptually](notes/0009_Behind_the_Underscores_EP01_Understanding_Pythons_Special_Methods_Conceptually.md)
* [Behind the Underscores EP02: Object Initialization and Construction Methods (`__new__`, `__init__`, `__del__`)](notes/0010_Behind_the_Underscores_EP02_Object_Initialization_and_Construction_Methods_new_init_del.md)
* [Behind the Underscores EP03: String Representation Methods (`__str__`, `__repr__`, `__format__`)](notes/0011_Behind_the_Underscores_EP03_String_Representation_Methods_str_repr_format.md)
* [Behind the Underscores EP04: Arithmetic Methods (`__add__`, `__sub__`, `__mul__`)](notes/0012_Behind_the_Underscores_EP04_Arithmetic_Methods_add_sub_mul.md)
* [Behind the Underscores EP05: Comparison Methods (`__eq__`, `__lt__`, `__gt__`)](notes/0013_Behind_the_Underscores_EP05_Comparison_Methods_eq_lt_gt.md)
* [Behind the Underscores EP06: Bitwise Methods (`__and__`, `__or__`, `__xor__`)](notes/0014_Behind_the_Underscores_EP06_Bitwise_Methods_and_or_xor.md)
* [Behind the Underscores EP07: Container protocol (`__getitem__`, `__setitem__`, `__delitem__`)](notes/0015_Behind_the_Underscores_EP07_Container_protocol_getitem_setitem_delitem.md)
* [Behind the Underscores EP08: Length and iteration Methods (`__len__`, `__iter__`, `__next__`, `__contains__`)](notes/0016_Behind_the_Underscores_EP08_Length_and_iteration_Methods_len_iter_next_contains.md)
* [Behind the Underscores EP09: Attribute Access (`__getattr__`, `__getattribute__`, `__setattr__`, `__delattr__`)](notes/0017_Behind_the_Underscores_EP09_Attribute_Access_getattr_getattribute_setattr_delattr.md)
* [Behind the Underscores EP10: Context Management (`__enter__`, `__exit__`)](notes/0018_Behind_the_Underscores_EP10_Context_Management_enter_exit.md)
* [Behind the Underscores EP11: Callable Objects: `__call__`](notes/0019_Behind_the_Underscores_EP11_Callable_Objects_call.md)
* [Behind the Underscores EP12: Descriptor Protocol (`__get__`, `__set__`, `__delete__`)](notes/0020_Behind_the_Underscores_EP12_Descriptor_Protocol_get_set_delete.md)
* [Behind the Underscores EP13: Metaprogramming Methods (`__class__`, `__bases__`, `__mro__`, `__instancecheck__`)](notes/0021_Behind_the_Underscores_EP13_Metaprogramming_Methods_class_bases_mro_instancecheck.md)
* [Understanding Async Context Managers in Python](notes/0022_Understanding_Async_Context_Managers_in_Python.md)
* [How the GIL Affects Real Python Workloads](notes/0023_How_the_GIL_Affects_Real_Python_Workloads.md)
* [Slotted classes with `__slots__` in Python](notes/0024_Slotted_classes_with_slots_in_Python.md)
* [The Art of Scope Management in Modular Python Design](notes/0025_The_Art_of_Scope_Management_in_Modular_Python_Design.md)
* [Designing Retryable Asynchronous APIs Using functools.partial and Custom Decorators](notes/0026_Designing_Retryable_Asynchronous_APIs_Using_functools_partial_and_Custom_Decorators.md)
* [Dataclasses vs Pydantic vs TypedDict vs NamedTuple in Python](notes/0027_Dataclasses_vs_Pydantic_vs_TypedDict_vs_NamedTuple_in_Python.md)
* [Why Composition Beats Inheritance in Large-Scale Python Systems](notes/0028_Why_Composition_Beats_Inheritance_in_Large_Scale_Python_Systems.md)
* [Encapsulation and Domain-Driven Design in Python Projects](notes/0029_Encapsulation_and_Domain_Driven_Design_in_Python_Projects.md)
* [Instance vs Class vs Static Methods in Python](notes/0030_Instance_vs_Class_vs_Static_Methods_in_Python.md)
* [Combining Abstract Classes with Factory and Strategy Patterns in Python](notes/0031_Combining_Abstract_Classes_with_Factory_and_Strategy_Patterns_in_Python.md)
* [Architecting a Multithreaded Log Monitor in Python](notes/0032_Architecting_a_Multithreaded_Log_Monitor_in_Python.md)
* [Advanced Shared State Management in Python Multiprocessing](notes/0033_Advanced_Shared_State_Management_in_Python_Multiprocessing.md)
* [Mastering Task Lifecycle in Python’s asyncio](notes/0034_Mastering_Task_Lifecycle_in_Pythons_asyncio.md)
* [Designing Robust Transaction Management with Nested Transactions and Savepoints in SQLAlchemy](notes/0035_Designing_Robust_Transaction_Management_with_Nested_Transactions_and_Savepoints_in_SQLAlchemy.md)
* [Optimistic vs. Pessimistic Locking in ORMs](notes/0036_Optimistic_vs_Pessimistic_Locking_in_ORMs.md)
* [Designing Reusable and Scalable ORM Models with Declarative Base and Mixins](notes/0037_Designing_Reusable_and_Scalable_ORM_Models_with_Declarative_Base_and_Mixins.md)
* [How to Defeat the N+1 Problem with joinedload, selectinload, and subqueryload](notes/0038_How_to_Defeat_the_N1_Problem_with_joinedload_selectinload_and_subqueryload.md)


